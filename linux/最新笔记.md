## 0.ftp服务器配置

#### 0.1虚拟机网络配置

进入虚拟机
cd /etc/sysconfig/network-scripts/ #进入网络配置文件目录,编辑配置文件：vi ifcfg-ens33

配置完毕重启网络
service network restart

IPADDR=192.168.137.104  根据网段，选择网段中的任意一个即可
GATEWAY=192.168.137.2   网关(虚拟机会分配好)
DNS1=192.168.137.2          DNS和网关保持一致



ftp服务端：

首先下载vsftp：(sudo) yum install vsftpd  或 （sudo）apt-get install vsftpd

（既能作为服务器端，也能作为客户端）

配置文件：cd /etc     sudo vi vsftpd.conf (不加sudo没权限修改)

![image-20210805152626334](F:\Typora\笔记\Go语言笔记图片\image-20210805152626334.png)

重新启动vsftpd服务：sudo service vsftpd restart（在此之前需要配置好相关的文件）



ftp客户端：

(sudo) yum install ftp  可以自动安装ftp客户端

（仅作为客户端）



1>  实名登录 --  不安全，别人需要知道我的用户名和密码，且可以上传输数据到我系统的任意目录

ftp+ip地址 (服务器server)  

输入用户名和密码（server）

put + 文件（将文件从客户端上传至服务端，上传的文件是客户端登陆时当前目录的文件）

get + 文件   (将文件从服务器下载到客户端)

不允许操作目录，如果想操作目录 --  打包 tar/rar/zip



2> 匿名登录

ftp+serverIP

用户名：anonymous

密码：直接回车

不允许匿名用户在任意目录切换，只能在一个指定的目录范围内工作

需要在ftp服务器上创建一个匿名用户目录 -- 匿名用户的根目录

给权限：chmod 777 abc  （abc是目录名）

(但我们登录后无法对目录进行写操作，这是我们可以在服务器那端打开写权限，此时就可以写入数据了)



退出ftp服务器：quit/bye



#### 0.2 lftp的使用

![image-20210805152013853](F:\Typora\笔记\Go语言笔记图片\image-20210805152013853.png)

lpwd  查看当前用户目录，即客户端登陆时的目录

lcd    更改客户端登录时的目录

pwd  是远程连接道德服务器目录

（cd  匿名不可改  实名可改）



## 0.nfs服务器的使用

1》  服务端

net file system -> 网络文件共享系统，它允许网络中的计算机通过TCP/IP网络共享资源

1.安装：sudo apt-get install nfs-kernel-server

2.创建一个欲共享出去的目录，如：/home/xxx/xxx(/home/zaiyebuhui/abc)

3.打开配置文件：sudo vi /etc/exports

![image-20210805161644327](F:\Typora\笔记\Go语言笔记图片\image-20210805161644327.png)

5.重启服务：sudo service nfs-kernel-server restart



2》客户端

1.挂在服务器共享目录

mount  serverIP:sharedir /mnt(mount 192.168.0.105:/home/zaiyebuhui/NfsShare /mnt)

## 1.命令解析器

shell 命令     unix操作系统

bash 命令    linux操作系统

## 2.linux快捷键

Ctrl P   切换到上一个命令（即方向键上）

Ctrl N   切换到下一个命令（即方向键下）

Ctrl B  切换到下一个命令（即方向键前）

Ctrl F   切换到下一个命令（即方向键后）

Ctrl A   运动到行首

Ctrl E  运动到行首

Ctrl H  删除光标前一个字符

Ctrl D  删除光标所覆盖的字符（即光标后的一个字符）

Ctrl H  删除光标前面所有的字符

## 3.tab键的使用

date  显示当前时间

history 显示之前所有的操作命令

在输入其他命令时不记得，按tab键进行补全

连按两次tab可以列出当前目录下的所有子目录

## 4.目录结构



## 5.gcc的编译过程

<img src="F:\Typora\笔记\Go语言笔记图片\image-20210715173231487.png" alt="image-20210715173231487" style="zoom:100%;" />

gcc-编译器那步最浪费时间

![image-20210715172806022](F:\Typora\笔记\Go语言笔记图片\image-20210715172806022.png)

无论是这样分步生成可执行文件，还是一步生成可执行文件（其内部都是要经过一步步处理的，只不过我们看不到）

![image-20210715174636796](F:\Typora\笔记\Go语言笔记图片\image-20210715174636796.png)

- 若代码中的某个头文件不存在于当前代码文件所在目录下

  （可以用-I +头文件所在路径 来让编译器在编译时自己取该路径目录下找想要的头文件）

- 当代码中缺少我们想要的宏定义时

  （可以通过-D+ 宏来让程序执行，即不在代码中写宏定义，转而在编译的时候指定我们想要使用的宏）

- -O+(数字0~3)指定想要优化的等级，可以让我们程序中冗余的代码进行优化

- -Wall  在程序编译时，提示错误信息

- -g      在程序中添加一些调试信息，生成的程序也会比正常的大一些

  （一般在程序发布时不加-g，但在一般调试时是需要加的，不然的话是看不到调试信息且没办法调试的）

- -o  指定生成的文件名

  

## 6.静态库的制作和使用（即windows中的lib）

![image-20210715202554955](F:\Typora\笔记\Go语言笔记图片\image-20210715202554955.png)



![image-20210715202522334](F:\Typora\笔记\Go语言笔记图片\image-20210715202522334.png)

先到对应.c文件夹下将.c文件生成为.o文件，这里因为头文件在include文件夹下，且没有用-Iinclude 所以报错



![image-20210715203224438](F:\Typora\笔记\Go语言笔记图片\image-20210715203224438.png)

查看头文件head.h中提供了哪些接口，注意这里只有函数申明，没有定义

（定义都包含在之前src中.c文件所生成的.o文件里了，且已经打包好放到了静态库中）



![image-20210715203459220](F:\Typora\笔记\Go语言笔记图片\image-20210715203459220.png)

写一个main.c文件对接口进行测试，测试时需要调用静态库和头文件



![image-20210715203633394](F:\Typora\笔记\Go语言笔记图片\image-20210715203633394.png)

另一种调用 静态库的方式，-l后面跟的是静态库名称，前面有介绍啥时静态库名



**nm 可查看静态库或可执行文件中有哪些东西**



**静态库的优缺点**

![image-20210715210147225](F:\Typora\笔记\Go语言笔记图片\image-20210715210147225.png)

当用静态库生成可执行文件时，需要用到的内容会被嵌入可执行文件中，所以发布程序时，不需要连同着静态库一起发布



## 7.动态库(共享库)的制作和使用 （即windows中的ddl）

![image-20210715212709703](F:\Typora\笔记\Go语言笔记图片\image-20210715212709703.png)

程序启动之后才会去加载动态库中的代码（将动态库中的代码加载至共享库里 ）



**动态库的生成和打包**

正常情况下第二种情况应该是执行不了的，需要我们将生成的动态库，复制到跟目下的lib目录中，这样之后**动态链接器**才能找到它

![image-20210715213031897](F:\Typora\笔记\Go语言笔记图片\image-20210715213031897.png)



把静态库移除，然后将.so和include打包发给用户

![image-20210715213219763](F:\Typora\笔记\Go语言笔记图片\image-20210715213219763.png)





通过这个命令我们可以看到动态链接器调用其他动态链接库的路径

![image-20210717231113704](F:\Typora\笔记\Go语言笔记图片\image-20210717231113704.png)



1.第一种使库被调用方式

用管理员权限将我们要用到的动态库移至/lib中（也就是系统的库目录中），然后就可以正常调用了

（**因为大部分加载的库都放在/lib里面，使其能够连接到，但一般并不推荐这么做**）

![image-20210717232413627](F:\Typora\笔记\Go语言笔记图片\image-20210717232413627.png)

2.第二种使库被调用方式

**系统会给我们提供额外搜索动态库的环境变量，我们可以在其中设置了一个目录，这个目录就是我们当前目录下的lib目录，这样后面动态链接库就可以搜索到这个路径了**（可以先赋值，再导入），这里是在赋值的同时直接导入

![image-20210717233730385](F:\Typora\笔记\Go语言笔记图片\image-20210717233730385.png)





**但这个设置只是临时的，并不是永久的，当关掉中端过后，我们刚刚设置的链接路径就失效了，我们可以用这个来做一个临时测试**，为的是将这个库临时导入到系统的环境变量中（仅是开发过程是使用的一种方法，不是永久设置的）





3.第三种使库被调用方式（**永久**）

将库设置到当前用户的bash目录下（bash目录在家目录下）

![image-20210717234355638](F:\Typora\笔记\Go语言笔记图片\image-20210717234355638.png)



将这个路径写入bash文件中，但写完之后需要关闭终端才能生效，下方那个**做了注释**（没用真正写入）

![image-20210717234214824](F:\Typora\笔记\Go语言笔记图片\image-20210717234214824.png)



4.第四种使库被调用方式（**重要**）

1.先找到动态链接器的配置文件

2.动态库的路径写道配置文件中

3.更新  sudo ldconfig -v(v在这里做一个信息的输出) 更新并查看所有的动态库

![image-20210718155021117](F:\Typora\笔记\Go语言笔记图片\image-20210718155021117.png)



把动态库的目录写进去

![image-20210718155116465](F:\Typora\笔记\Go语言笔记图片\image-20210718155116465.png)



切换回项目目录下，用命令ldd myapp(myapp是要运行程序的名称)即可看到链接库查找到所需要库的路径，此时都能被找到

![image-20210718155521321](F:\Typora\笔记\Go语言笔记图片\image-20210718155521321.png)

5.制作总结

![image-20210718160032304](F:\Typora\笔记\Go语言笔记图片\image-20210718160032304.png)



**动态库的优缺点**

![image-20210718160612206](F:\Typora\笔记\Go语言笔记图片\image-20210718160612206.png)



## 8，总结

![image-20210718162536949](F:\Typora\笔记\Go语言笔记图片\image-20210718162536949.png)

![image-20210718162555581](F:\Typora\笔记\Go语言笔记图片\image-20210718162555581.png)



## 9.gdb调试

![image-20210727123505380](F:\Typora\笔记\Go语言笔记图片\image-20210727123505380.png)

g++ add.cpp -o add -g  (生成具有调试信息的可执行文件add)

1.gdb+文件名可以进行调试（gdb add）

2.查看想要调试的代码信息

![image-20210727183831102](F:\Typora\笔记\Go语言笔记图片\image-20210727183831102.png)

l：查看所有代码信息    （只显示10行，如果想要看接下来的，直接按回车）

l+文件名+行号：查看某文件中某行的代码信息

l+文件名+函数名：查看某文件中某函数的代码信息

（之后要是向看之后的内容，输入l，按下回车即可看接下来10行的内容，l只用输入一次）

3.gdb的一些操作命令

start  开始运行gdb（会一步一步执行）

r（run）  运行至第一个断点处，若代码中没有断点，程序会直接执行结束

b +行号  在某行处打断点 

b 17 if i==15   当i=15时，在17行设置一个断点，注意断点不能设置在循环for循环语句那行，需设置在其循环内部的语句里

i b   查看所有的断点信息

info b  获取断点的编号

del+断点的编号  删除断点

n  单步调试

c   运行至下一个断点处

u  跳出单次循环（类似于continue）

s  进入函数内部

finish  跳出当前的函数(如果函数中的循环处有断点，要么等循环结束，要么取消断点，否则是没办法跳出去的)

p+变量   查看变量现在的值

ptype+变量   查看变量的类型

display+变量   追踪变量的值

info display 获取所有追踪变量的编号

undisplay+编号  停止对某一变量的追踪

set var i=10   提前预设值，可以在循环中使用，让循环运行至预设位置

quit  退出gdb



4.总结

![image-20210727203810173](F:\Typora\笔记\Go语言笔记图片\image-20210727203810173.png)

![image-20210727203846881](F:\Typora\笔记\Go语言笔记图片\image-20210727203846881.png)



## 10.makefile的编写

![image-20210730124515537](F:\Typora\笔记\Go语言笔记图片\image-20210730124515537.png)



1.第一种最简单写法

![image-20210730124307664](F:\Typora\笔记\Go语言笔记图片\image-20210730124307664.png)

目标：app   

依赖文件：main.c  add.c   .....

执行语句(规则)：gcc main.c .....

(如果依赖文件不在当前目录，那么需要我们指出其所在的目录)



2.分别处理

![image-20210730133444305](F:\Typora\笔记\Go语言笔记图片\image-20210730133444305.png)

![image-20210730134110298](F:\Typora\笔记\Go语言笔记图片\image-20210730134110298.png)        

​       当最终依赖的文件没有时，会往下找，发现跟依赖文件有关的规则后就会去执行那些规则

**这种写法：哪个cpp文件发生变化就编译哪个，其他的文件不会编译，可以节约时间**

![image-20210730134527522](F:\Typora\笔记\Go语言笔记图片\image-20210730134527522.png)

​                    （通过文件的更新时间来决定，某个文件是否要重新编译）

3.makefile中的自动变量该如何使用

![image-20210730145316209](F:\Typora\笔记\Go语言笔记图片\image-20210730145316209.png)

![image-20210730150151144](F:\Typora\笔记\Go语言笔记图片\image-20210730150151144.png)

​                                                        **总览**

4.makefile中的函数

![image-20210730191055843](F:\Typora\笔记\Go语言笔记图片\image-20210730191055843.png)

![image-20210730191040709](F:\Typora\笔记\Go语言笔记图片\image-20210730191040709.png)

上图clean/hello 都没有生成一个文件  但我们没有其伪目标

所以在执行时会做做一个更新的比较，若当前目录有存在clean那么就不会执行

![image-20210730191339133](F:\Typora\笔记\Go语言笔记图片\image-20210730191339133.png)

​                                            这样声明下伪目标就可以了

![image-20210730191643502](F:\Typora\笔记\Go语言笔记图片\image-20210730191643502.png)

加 -  的 意思时，如果这条命令执行失败了会继续执行后面的命令，反之卡死 





## 11.C库函数

![image-20210730222424173](F:\Typora\笔记\Go语言笔记图片\image-20210730222424173.png)

1.磁盘直接和内存交换信息速度非常慢，于是用缓冲区来进行数据交换，这样能提高速度（linux系统是没有这个缓存的，C库函数是给我们封装了一个IO缓冲区来提高程序速度）

2.文件中只有一个读写指针，要注意读写操作的执行，又写又读会出错



#### 1.虚拟地址空间介绍

![image-20210730223315619](F:\Typora\笔记\Go语言笔记图片\image-20210730223315619.png)

![image-20210731145526918](F:\Typora\笔记\Go语言笔记图片\image-20210731145526918.png)

#### 2.C库函数与系统函数的关系

![image-20210731153222323](F:\Typora\笔记\Go语言笔记图片\image-20210731153222323.png)

## 12.几种系统函数的介绍

man文档首页（man man即可查看）

![image-20210803144321306](F:\Typora\笔记\Go语言笔记图片\image-20210803144321306.png)

#### 1.open函数

![image-20210803144423932](F:\Typora\笔记\Go语言笔记图片\image-20210803144423932.png)

2代表章节号，即使不加也没关系，它会从头寻找

